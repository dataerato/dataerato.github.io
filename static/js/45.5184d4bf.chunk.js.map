{"version":3,"sources":["pages/EditPage/EditView/DropView.js"],"names":["calcIndex","pos","prev","insert","candidates","document","getElementsByClassName","index","updateFlag","slot","box","getBoundingClientRect","x","left","width","y","top","bottom","updateSingleFlag","update","right","style","recordbreakTimes","recordPreIndex","cardDropTarget","hover","props","monitor","component","getClientOffset","hoverFactIndex","setHoverIndex","drop","didDrop","cardDrop","containerRef","React","createRef","prevProps","isOver","this","isOverCurrent","children","connectDropTarget","Component","DropTarget","connect","dropTarget","canDrop"],"mappings":"qLAWMA,EAAY,SAASC,GACvB,IAIIC,EACAC,EANuB,EACvBC,EAAaC,SAASC,uBAAuB,wBAG7CC,EAAQ,EAGRC,GAAW,EAPY,cASXJ,GATW,IAS3B,IAAI,EAAJ,qBAA2B,CAAC,IAApBK,EAAmB,QACnBC,EAAMD,EAAKE,wBAmBX,GAAGV,EAAIW,GAAKF,EAAIG,KAAOH,EAAII,MAAM,GAAKb,EAAIW,GAAKF,EAAIG,KA1BzC,IA0B6DZ,EAAIc,GAAKL,EAAIM,KAAOf,EAAIc,GAAKL,EAAIO,OACpG,MAAO,CAAEd,OAAQI,EAAOW,kBAAiB,EAAMC,YAtBvDA,GAwBI,GAAGlB,EAAIW,GAAKF,EAAIU,MAAQV,EAAII,MAAM,GAAKb,EAAIW,GAAKF,EAAIG,KAAOH,EAAII,MAAM,GAAKb,EAAIc,GAAKL,EAAIM,KAAOf,EAAIc,GAAKL,EAAIO,OAEvG,OADAR,EAAKY,MAAL,WAAyB,mBAClB,CAAElB,OAAQA,EAAQe,kBAAiB,EAAKC,OAAOZ,GAG9DA,IACAL,EAAOQ,GAtCgB,8BAwC3B,OAAIR,IAEAC,GAAUD,GAAQD,EAAIW,GAAKV,EAAKkB,MAvClB,IAuCuCnB,EAAIW,GAAKV,EAAKkB,MAAQlB,EAAKY,MAAM,GAAKb,EAAIc,GAAKb,EAAKc,KAAOf,EAAIc,GAAKb,EAAKe,SAC9Hd,EAASI,EACTC,GAAW,GAEZP,EAAIc,EAAIb,EAAKe,QAAUhB,EAAIc,GAAKb,EAAKe,OA3CtB,KA4Cdd,EAASI,EACTC,GAAW,GAGR,CAAEL,OAAQA,EAAQe,iBAAiBV,EAAYW,YA3ClDA,IAgCa,CAAEhB,OAAQ,EAAGe,kBAAiB,EAAMC,YAhCjDA,IAiDJG,EAAiB,EACjBC,GAAgB,EACdC,EAAiB,CACnBC,MADmB,SACbC,EAAOC,EAASC,GAelB,IAAI3B,EAAM0B,EAAQE,kBAElBN,EAAeG,EAAMI,eAClB9B,EAAUC,GAAKE,SACXmB,EAAiB,GAChBM,EAAUF,MAAMK,cAAc/B,EAAUC,GAAKE,QAG9CH,EAAUC,GAAKE,SAASoB,GAAgBD,IACxCtB,EAAUC,GAAKE,SAASoB,IAAgBD,EAAiB,KAIpEU,KA7BmB,SA6BdN,EAAOC,EAASC,GACjB,IAAID,EAAQM,UAAZ,CAOAL,EAAUF,MAAMK,eAAe,GAC/B,IAAI9B,EAAM0B,EAAQE,kBAClB,OAAO7B,EAAUC,M,IAoBnBiC,E,kDACF,WAAYR,GAAQ,IAAD,8BACf,cAAMA,IACDS,aAAeC,IAAMC,YAFX,E,+DAKAC,IACVA,EAAUC,QAAUC,KAAKd,MAAMa,OAIhCD,EAAUC,QAAWC,KAAKd,MAAMa,OAIhCD,EAAUG,eAAkBD,KAAKd,MAAMe,gB,+BAMtC,IAEGC,EAAaF,KAAKd,MAAlBgB,SAIAC,EAAsBH,KAAKd,MAA3BiB,kBACR,OAAOA,GAAqBA,EACxBD,O,GA7BWN,IAAMQ,WAkCdC,+BA3JL,OA6JRrB,GAjDF,SAAiBsB,EAASnB,GACxB,MAAO,CAGLgB,kBAAmBG,EAAQC,aAE3BR,OAAQZ,EAAQY,SAEhBS,QAASrB,EAAQqB,aAuCNH,CAIbX","file":"static/js/45.5184d4bf.chunk.js","sourcesContent":["import React from 'react'\nimport { DropTarget } from 'react-dnd'\n\n// Drag sources and drop targets only interact\n// if they have the same string type.\n// You want to keep types in a separate file with\n// the rest of your app's constants.\nconst Types = {\n    CARD: 'card'\n}\n\nconst calcIndex = function(pos){\n    let candidates = document.getElementsByClassName(\"creatstory-eventview\");\n        \n    const borderGap = 60;\n    let index = 0;\n    let prev;\n    let insert;\n    let updateFlag=false;\n    let update;\n    for(let slot of candidates){\n        let box = slot.getBoundingClientRect();\n        // if(index === 0 || Math.floor(box.y) !== Math.floor(prev.y)){//first one in one row \n        //     if(pos.x <= box.left + box.width/2 && pos.x >= box.left - borderGap && pos.y >= box.top && pos.y <= box.bottom){\n        //         return { insert: index }\n        //     }\n        //     if(index === 0 && pos.y >= box.top - borderGap && pos.y < box.top){//title\n        //         return { insert: index }\n        //     }\n        //     if(prev && pos.y > prev.bottom && pos.y < box.top){//between row\n        //         return { insert: index }\n        //     }\n        //     if(prev && pos.x <= prev.right + borderGap && pos.x >= prev.right - prev.width/2 && pos.y >= prev.top && pos.y <= prev.bottom){//last one in one row\n        //         return { insert: index }\n        //     }\n        // }else{\n        //     if(pos.x <= box.left + box.width/2 && pos.x >= prev.right - prev.width/2 && pos.y >= box.top && pos.y <= box.bottom){\n        //         return { insert: index }\n        //     }\n        // }\n            if(pos.x <= box.left + box.width/4 && pos.x >= box.left - borderGap && pos.y >= box.top && pos.y <= box.bottom){\n                return { insert: index ,updateSingleFlag:false,update:update}\n            }\n            if(pos.x <= box.right - box.width/4 && pos.x >= box.left + box.width/4 && pos.y >= box.top && pos.y <= box.bottom){\n                slot.style['background']=\"rgb(255, 176, 7)\"\n                return { insert: insert ,updateSingleFlag:true,update:index}\n            }\n\n        index ++;\n        prev = box;\n    }\n    if(!prev) return { insert: 0 ,updateSingleFlag:false,update:update}\n    //last one\n    if(!insert && prev && pos.x <= prev.right + borderGap && pos.x >= prev.right - prev.width/2 && pos.y >= prev.top && pos.y <= prev.bottom){\n        insert = index;\n        updateFlag=false;\n    }\n    if(pos.y > prev.bottom && pos.y <= prev.bottom + borderGap){\n        insert = index;\n        updateFlag=false;\n    }\n\n    return { insert: insert ,updateSingleFlag:updateFlag, update:update}\n}\n/**\n * Specifies the drop target contract.\n * All methods are optional.\n */\nlet recordbreakTimes=0;\nlet recordPreIndex=-1;\nconst cardDropTarget = {\n    hover(props, monitor, component) {\n        // This is fired very often and lets you perform side effects\n        // in response to the hover. You can't handle enter and leave\n        // hereâ€”if you need them, put monitor.isOver() into collect() so you\n        // can use componentDidUpdate() to handle enter/leave.\n\n        // You can access the coordinates if you need them\n        // const clientOffset = monitor.getClientOffset()\n        // const componentRect = findDOMNode(component).getBoundingClientRect()\n\n        // // You can check whether we're over a nested drop target\n        // const isOnlyThisOne = monitor.isOver({ shallow: true })\n\n        // // You will receive hover() even for items for which canDrop() is false\n        // const canDrop = monitor.canDrop()\n        let pos = monitor.getClientOffset();\n       \n        recordPreIndex=props.hoverFactIndex\n        if(calcIndex(pos).insert){\n            if(recordbreakTimes<1){\n                component.props.setHoverIndex(calcIndex(pos).insert);\n                // recordbreakTimes=0\n            } \n            if(calcIndex(pos).insert===recordPreIndex) recordbreakTimes++;\n            if(calcIndex(pos).insert!==recordPreIndex) recordbreakTimes=0;\n        }\n    },\n\n    drop(props, monitor, component) {\n        if (monitor.didDrop()) {\n            // If you want, you can check whether some nested\n            // target already handled drop\n            return\n        }\n\n        // Obtain the dragged item\n        component.props.setHoverIndex(-1);\n        let pos = monitor.getClientOffset();\n        return calcIndex(pos);\n    }\n}\n\n/**\n * Specifies which props to inject into your component.\n */\nfunction collect(connect, monitor) {\n  return {\n    // Call this function inside render()\n    // to let React DnD handle the drag events:\n    connectDropTarget: connect.dropTarget(),\n    // You can ask the monitor about the current drag state:\n    isOver: monitor.isOver(),\n    // isOverCurrent: monitor.isOver({ shallow: true }),\n    canDrop: monitor.canDrop(),\n    // itemType: monitor.getItemType()\n  }\n}\n\nclass cardDrop extends React.Component{\n    constructor(props) {\n        super(props);\n        this.containerRef = React.createRef()\n    }\n\n    componentDidUpdate(prevProps) {\n        if (!prevProps.isOver && this.props.isOver) {\n        // You can use this as enter handler\n        }\n\n        if (prevProps.isOver && !this.props.isOver) {\n        // You can use this as leave handler\n        }\n\n        if (prevProps.isOverCurrent && !this.props.isOverCurrent) {\n        // You can be more specific and track enter/leave\n        // shallowly, not including nested targets\n        }\n    }\n\n    render() {\n        // Your component receives its own props as usual\n        const { children } = this.props\n\n        // These props are injected by React DnD,\n        // as defined by your `collect` function above:\n        const { connectDropTarget } = this.props\n        return connectDropTarget && connectDropTarget(\n            children\n        )\n    }\n}\n\nexport default DropTarget(\n  Types.CARD,\n  cardDropTarget,\n  collect\n)(cardDrop)\n"],"sourceRoot":""}